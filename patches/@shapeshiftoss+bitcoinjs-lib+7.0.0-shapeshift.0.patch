diff --git a/node_modules/@shapeshiftoss/bitcoinjs-lib/src/cjs/psbt.cjs b/node_modules/@shapeshiftoss/bitcoinjs-lib/src/cjs/psbt.cjs
index bcad894..c3c84b2 100644
--- a/node_modules/@shapeshiftoss/bitcoinjs-lib/src/cjs/psbt.cjs
+++ b/node_modules/@shapeshiftoss/bitcoinjs-lib/src/cjs/psbt.cjs
@@ -459,14 +459,14 @@ class Psbt {
       !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine)
     );
   }
-  validateSignaturesOfAllInputs(validator) {
+  validateSignaturesOfAllInputs(validator, singleHash = false) {
     (0, bip174_2.checkForInput)(this.data.inputs, 0); // making sure we have at least one
     const results = range(this.data.inputs.length).map(idx =>
-      this.validateSignaturesOfInput(idx, validator),
+      this.validateSignaturesOfInput(idx, validator, singleHash),
     );
     return results.reduce((final, res) => res === true && final, true);
   }
-  validateSignaturesOfInput(inputIndex, validator, pubkey) {
+  validateSignaturesOfInput(inputIndex, validator, pubkey, singleHash = false) {
     const input = this.data.inputs[inputIndex];
     if ((0, bip371_js_1.isTaprootInput)(input))
       return this.validateSignaturesOfTaprootInput(
@@ -474,9 +474,9 @@ class Psbt {
         validator,
         pubkey,
       );
-    return this._validateSignaturesOfInput(inputIndex, validator, pubkey);
+    return this._validateSignaturesOfInput(inputIndex, validator, pubkey, singleHash);
   }
-  _validateSignaturesOfInput(inputIndex, validator, pubkey) {
+  _validateSignaturesOfInput(inputIndex, validator, pubkey, singleHash) {
     const input = this.data.inputs[inputIndex];
     const partialSig = (input || {}).partialSig;
     if (!input || !partialSig || partialSig.length < 1)
@@ -501,6 +501,7 @@ class Psbt {
               this.__CACHE,
               true,
               this.opts.forkCoin,
+              singleHash,
             )
           : { hash: hashCache, script: scriptCache };
       sighashCache = sig.hashType;
@@ -582,7 +583,7 @@ class Psbt {
     }
     return this;
   }
-  signAllInputsHDAsync(hdKeyPair, sighashTypes) {
+  signAllInputsHDAsync(hdKeyPair, sighashTypes, singleHash = false) {
     return new Promise((resolve, reject) => {
       if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
         return reject(new Error('Need HDSigner to sign input'));
@@ -591,7 +592,7 @@ class Psbt {
       const promises = [];
       for (const i of range(this.data.inputs.length)) {
         promises.push(
-          this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(
+          this.signInputHDAsync(i, hdKeyPair, sighashTypes, singleHash).then(
             () => {
               results.push(true);
             },
@@ -617,14 +618,14 @@ class Psbt {
     signers.forEach(signer => this.signInput(inputIndex, signer, sighashTypes));
     return this;
   }
-  signInputHDAsync(inputIndex, hdKeyPair, sighashTypes) {
+  signInputHDAsync(inputIndex, hdKeyPair, sighashTypes, singleHash = false) {
     return new Promise((resolve, reject) => {
       if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
         return reject(new Error('Need HDSigner to sign input'));
       }
       const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
       const promises = signers.map(signer =>
-        this.signInputAsync(inputIndex, signer, sighashTypes),
+        this.signInputAsync(inputIndex, signer, sighashTypes, singleHash),
       );
       return Promise.all(promises)
         .then(() => {
@@ -653,7 +654,7 @@ class Psbt {
     }
     return this;
   }
-  signAllInputsAsync(keyPair, sighashTypes) {
+  signAllInputsAsync(keyPair, sighashTypes, singleHash = false) {
     return new Promise((resolve, reject) => {
       if (!keyPair || !keyPair.publicKey)
         return reject(new Error('Need Signer to sign input'));
@@ -664,7 +665,7 @@ class Psbt {
       const promises = [];
       for (const [i] of this.data.inputs.entries()) {
         promises.push(
-          this.signInputAsync(i, keyPair, sighashTypes).then(
+          this.signInputAsync(i, keyPair, sighashTypes, singleHash).then(
             () => {
               results.push(true);
             },
@@ -772,7 +773,7 @@ class Psbt {
     }
     return this;
   }
-  signInputAsync(inputIndex, keyPair, sighashTypes) {
+  signInputAsync(inputIndex, keyPair, sighashTypes, singleHash = false) {
     return Promise.resolve().then(() => {
       if (!keyPair || !keyPair.publicKey)
         throw new Error('Need Signer to sign input');
@@ -785,7 +786,7 @@ class Psbt {
           undefined,
           sighashTypes,
         );
-      return this._signInputAsync(inputIndex, keyPair, sighashTypes);
+      return this._signInputAsync(inputIndex, keyPair, sighashTypes, singleHash);
     });
   }
   signTaprootInputAsync(inputIndex, keyPair, tapLeafHash, sighashTypes) {
@@ -804,7 +805,7 @@ class Psbt {
       throw new Error(`Input #${inputIndex} is not of type Taproot.`);
     });
   }
-  _signInputAsync(inputIndex, keyPair, sighashTypes = DEFAULT_SIGHASHES) {
+  _signInputAsync(inputIndex, keyPair, sighashTypes = DEFAULT_SIGHASHES, singleHash) {
     const { hash, sighashType } = getHashAndSighashType(
       this.data.inputs,
       inputIndex,
@@ -812,6 +813,7 @@ class Psbt {
       this.__CACHE,
       sighashTypes,
       this.opts.forkCoin,
+      singleHash,
     );
     return Promise.resolve(keyPair.sign(hash)).then(signature => {
       const partialSig = [
@@ -1237,6 +1239,7 @@ function getHashAndSighashType(
   cache,
   sighashTypes,
   forkCoin,
+  singleHash,
 ) {
   const input = (0, bip174_2.checkForInput)(inputs, inputIndex);
   const { hash, sighashType, script } = getHashForSig(
@@ -1246,6 +1249,7 @@ function getHashAndSighashType(
     false,
     forkCoin,
     sighashTypes,
+    singleHash,
   );
   checkScriptForPubkey(pubkey, script, 'sign');
   return {
@@ -1268,6 +1272,7 @@ function getHashForSig(
   forValidate,
   forkCoin,
   sighashTypes,
+  singleHash,
 ) {
   const unsignedTx = cache.__TX;
   const sighashType = input.sighashType || getDefaultSighash(forkCoin);
@@ -1310,6 +1315,7 @@ function getHashForSig(
       meaningfulScript,
       prevout.value,
       sighashType,
+      singleHash,
     );
   } else if ((0, psbtutils_js_1.isP2WPKH)(meaningfulScript)) {
     // P2WPKH uses the P2PKH template for prevoutScript when signing
@@ -1321,6 +1327,7 @@ function getHashForSig(
       signingScript,
       prevout.value,
       sighashType,
+      singleHash,
     );
   } else {
     // non-segwit
@@ -1351,12 +1358,14 @@ function getHashForSig(
         meaningfulScript,
         prevout.value,
         sighashType,
+        singleHash,
       );
     } else {
       hash = unsignedTx.hashForSignature(
         inputIndex,
         meaningfulScript,
         sighashType,
+        singleHash,
       );
     }
   }
diff --git a/node_modules/@shapeshiftoss/bitcoinjs-lib/src/cjs/psbt.d.ts b/node_modules/@shapeshiftoss/bitcoinjs-lib/src/cjs/psbt.d.ts
index e1774de..3fb37fa 100644
--- a/node_modules/@shapeshiftoss/bitcoinjs-lib/src/cjs/psbt.d.ts
+++ b/node_modules/@shapeshiftoss/bitcoinjs-lib/src/cjs/psbt.d.ts
@@ -93,21 +93,21 @@ export declare class Psbt {
     inputHasHDKey(inputIndex: number, root: HDSigner): boolean;
     outputHasPubkey(outputIndex: number, pubkey: Uint8Array): boolean;
     outputHasHDKey(outputIndex: number, root: HDSigner): boolean;
-    validateSignaturesOfAllInputs(validator: ValidateSigFunction): boolean;
-    validateSignaturesOfInput(inputIndex: number, validator: ValidateSigFunction, pubkey?: Uint8Array): boolean;
+    validateSignaturesOfAllInputs(validator: ValidateSigFunction, singleHash?: boolean): boolean;
+    validateSignaturesOfInput(inputIndex: number, validator: ValidateSigFunction, pubkey?: Uint8Array, singleHash?: boolean): boolean;
     private _validateSignaturesOfInput;
     private validateSignaturesOfTaprootInput;
     signAllInputsHD(hdKeyPair: HDSigner, sighashTypes?: number[]): this;
-    signAllInputsHDAsync(hdKeyPair: HDSigner | HDSignerAsync, sighashTypes?: number[]): Promise<void>;
+    signAllInputsHDAsync(hdKeyPair: HDSigner | HDSignerAsync, sighashTypes?: number[], singleHash?: boolean): Promise<void>;
     signInputHD(inputIndex: number, hdKeyPair: HDSigner, sighashTypes?: number[]): this;
-    signInputHDAsync(inputIndex: number, hdKeyPair: HDSigner | HDSignerAsync, sighashTypes?: number[]): Promise<void>;
+    signInputHDAsync(inputIndex: number, hdKeyPair: HDSigner | HDSignerAsync, sighashTypes?: number[], singleHash?: boolean): Promise<void>;
     signAllInputs(keyPair: Signer, sighashTypes?: number[]): this;
-    signAllInputsAsync(keyPair: Signer | SignerAsync, sighashTypes?: number[]): Promise<void>;
+    signAllInputsAsync(keyPair: Signer | SignerAsync, sighashTypes?: number[], singleHash?: boolean): Promise<void>;
     signInput(inputIndex: number, keyPair: Signer, sighashTypes?: number[]): this;
     signTaprootInput(inputIndex: number, keyPair: Signer, tapLeafHashToSign?: Uint8Array, sighashTypes?: number[]): this;
     private _signInput;
     private _signTaprootInput;
-    signInputAsync(inputIndex: number, keyPair: Signer | SignerAsync, sighashTypes?: number[]): Promise<void>;
+    signInputAsync(inputIndex: number, keyPair: Signer | SignerAsync, sighashTypes?: number[], singleHash?: boolean): Promise<void>;
     signTaprootInputAsync(inputIndex: number, keyPair: Signer | SignerAsync, tapLeafHash?: Uint8Array, sighashTypes?: number[]): Promise<void>;
     private _signInputAsync;
     private _signTaprootInputAsync;
diff --git a/node_modules/@shapeshiftoss/bitcoinjs-lib/src/cjs/transaction.cjs b/node_modules/@shapeshiftoss/bitcoinjs-lib/src/cjs/transaction.cjs
index eb0d937..64df08d 100644
--- a/node_modules/@shapeshiftoss/bitcoinjs-lib/src/cjs/transaction.cjs
+++ b/node_modules/@shapeshiftoss/bitcoinjs-lib/src/cjs/transaction.cjs
@@ -260,7 +260,7 @@ class Transaction {
    * hashType, and then hashes the result.
    * This hash can then be used to sign the provided transaction input.
    */
-  hashForSignature(inIndex, prevOutScript, hashType) {
+  hashForSignature(inIndex, prevOutScript, hashType, singleHash) {
     v.parse(v.tuple([types.UInt32Schema, types.BufferSchema, v.number()]), [
       inIndex,
       prevOutScript,
@@ -315,7 +315,7 @@ class Transaction {
     const buffer = new Uint8Array(txTmp.byteLength(false) + 4);
     tools.writeInt32(buffer, buffer.length - 4, hashType, 'LE');
     txTmp.__toBuffer(buffer, 0, false);
-    return bcrypto.hash256(buffer);
+    return singleHash ? sha256_1.sha256(buffer) : bcrypto.hash256(buffer);
   }
   hashForWitnessV1(inIndex, prevOutScripts, values, hashType, leafHash, annex) {
     // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#common-signature-message
@@ -455,7 +455,7 @@ class Transaction {
       tools.concat([Uint8Array.from([0x00]), sigMsgWriter.end()]),
     );
   }
-  hashForWitnessV0(inIndex, prevOutScript, value, hashType) {
+  hashForWitnessV0(inIndex, prevOutScript, value, hashType, singleHash) {
     v.parse(
       v.tuple([
         types.UInt32Schema,
@@ -530,7 +530,7 @@ class Transaction {
     bufferWriter.writeSlice(hashOutputs);
     bufferWriter.writeUInt32(this.locktime);
     bufferWriter.writeUInt32(hashType);
-    return bcrypto.hash256(tbuffer);
+    return singleHash ? sha256_1.sha256(tbuffer) : bcrypto.hash256(tbuffer);
   }
   getHash(forWitness) {
     // wtxid for coinbase is always 32 bytes of 0x00
diff --git a/node_modules/@shapeshiftoss/bitcoinjs-lib/src/cjs/transaction.d.ts b/node_modules/@shapeshiftoss/bitcoinjs-lib/src/cjs/transaction.d.ts
index ed7decd..0226181 100644
--- a/node_modules/@shapeshiftoss/bitcoinjs-lib/src/cjs/transaction.d.ts
+++ b/node_modules/@shapeshiftoss/bitcoinjs-lib/src/cjs/transaction.d.ts
@@ -47,9 +47,9 @@ export declare class Transaction {
      * hashType, and then hashes the result.
      * This hash can then be used to sign the provided transaction input.
      */
-    hashForSignature(inIndex: number, prevOutScript: Uint8Array, hashType: number): Uint8Array;
+    hashForSignature(inIndex: number, prevOutScript: Uint8Array, hashType: number, singleHash: boolean): Uint8Array;
     hashForWitnessV1(inIndex: number, prevOutScripts: Uint8Array[], values: bigint[], hashType: number, leafHash?: Uint8Array, annex?: Uint8Array): Uint8Array;
-    hashForWitnessV0(inIndex: number, prevOutScript: Uint8Array, value: bigint, hashType: number): Uint8Array;
+    hashForWitnessV0(inIndex: number, prevOutScript: Uint8Array, value: bigint, hashType: number, singleHash: boolean): Uint8Array;
     getHash(forWitness?: boolean): Uint8Array;
     getId(): string;
     toBuffer(buffer?: Uint8Array, initialOffset?: number): Uint8Array;
